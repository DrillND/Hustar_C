#pragma config(Sensor, S1,     sensorColorRight, sensorEV3_Color)
#pragma config(Sensor, S2,     sensorColorMiddle, sensorEV3_Color)
#pragma config(Sensor, S4,     sensorColorLeft, sensorEV3_Color)
#pragma config(Motor,  motorA,          motorLeft,     tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor,  motorD,          motorRight,    tmotorEV3_Large, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#define TRUE 1
#define FALSE 0

#define NONE 0
#define BLACK 1
#define BLUE 2
#define GREEN 3
#define YELLOW 4
#define RED 5
#define WHITE 6
#define BROWN 7

#define LED_OFF 0
#define LED_GREEN 1
#define LED_RED 2
#define LED_ORANGE 3
#define LED_GREEN_FLASH 4
#define LED_RED_FLASH 5
#define LED_ORANGE_FLASH 6
#define LED_GREEN_PULSE 7
#define LED_RED_PULSE 8
#define LED_ORANGE_PULSE 9

#define LOW_C 523
#define LOW_C_SHARP 554
#define LOW_D 587
#define LOW_D_SHARP 622
#define LOW_E 659
#define LOW_F 699
#define LOW_F_SHARP 740
#define LOW_G 784
#define LOW_G_SHARP 831
#define LOW_A 880
#define LOW_A_SHARP 932
#define LOW_B 988
#define HIGH_C 1047
#define HIGH_C_SHARP 1109
#define HIGH_D 1175
#define HIGH_D_SHARP 1245
#define HIGH_E 1319
#define HIGH_F 1397
#define HIGH_F_SHARP 1475
#define HIGH_G 1568
#define HIGH_G_SHARP 1661
#define HIGH_A 1760
#define HIGH_A_SHARP 1865
#define HIGH_B 1976

#define MSEC_0_05 50
#define MSEC_0_10 100
#define MSEC_0_50 500
#define MSEC_1_00 1000

int sensorL, sensorM, sensorR;
int blackValue=0, whiteValue=0, threshold=0;

void move(int motorSpeedLeft, int motorSpeedRight)
{
   setMotorSpeed(motorLeft, motorSpeedLeft);
   setMotorSpeed(motorRight, motorSpeedRight);

}

void stopp()
{
   setMotorSpeed(motorLeft, 0);
   setMotorSpeed(motorRight, 0);

}



void turnRight()
{
	while(sensorM <= threshold)
	{
		move(20*5/10,-20*5/10);
	}
	while(sensorM > threshold)
	{
		move(20*5/10,-20*5/10);
	}
	stopp();
}

task main()
{
   int v = 30;
   int error = 0;
   int sum = 0;
   int diff = 0;
   int last_error = 0;


   float Kp = 0.2;
   float Kd = 50;
   float Ki = Kp*Kp/(4*Kd);


   //sensorL = 0;
	 //sensorM = 0;
	 //sensorR = 0;
	 blackValue=0;
	 whiteValue=0;
	 threshold=0;

   // Calibration(black)
   while(TRUE)
   {
      displayBigTextLine(1, "Read(black)..");
      if(getButtonPress(TRUE))
      {
      	for(int i = 0; i<5; i++)
      	{
      		blackValue += getColorReflected(sensorColorMiddle);
      		sleep(10);
      	}

       playImmediateTone(LOW_C, MSEC_0_05);
       sleep(MSEC_0_50);
       displayBigTextLine(1, "(black)done");
       sleep(1500);
       break;
      }
   }

   // Calibration(white)
   while(TRUE)
   {
      displayBigTextLine(1, "Read(white)..");
      if(getButtonPress(TRUE))
      {
      	for(int i = 0; i<5; i++)
      	{
      		whiteValue += getColorReflected(sensorColorMiddle);
      		sleep(10);
      	}

         playImmediateTone(HIGH_C, MSEC_0_05);
         sleep(MSEC_0_50);
         displayBigTextLine(1, "(white)done");
         sleep(1500);



         break;
      }
   }

   // Calculate threshold
   threshold = ((blackValue/5 + whiteValue/5)) / 2;
   displayBigTextLine(1, "threshold : %d",threshold);
   sleep(3000);

    displayBigTextLine(1, "Press Botton");
    displayBigTextLine(4, "To Start");

    sleep(1500);
    displayBigTextLine(4, "");

   // Ready
   while(TRUE)
   {
      if(getButtonPress(TRUE))
      {
         break;
      }
   }

   // PID Control
   while(TRUE)
   {
     	sensorL = getColorReflected(sensorColorLeft);
			sensorM = getColorReflected(sensorColorMiddle);
			sensorR = getColorReflected(sensorColorRight);
      error = getColorReflected(sensorColorMiddle) - threshold; // P control
      sum += error; // PI control
      diff = error - last_error; // PID control
      move(v+(error*Kp + sum*Ki + diff*Kd), v-(error*Kp + sum*Ki + diff*Kd));
      last_error = error;


      if(sensorR < threshold || sensorL < threshold)
      {
      	displayBigTextLine(1, "sensorR:%d<Th:%d",sensorR,threshold);
      	displayBigTextLine(4, "sensorL:%d<Th:%d",sensorL,threshold);
      	sleep(3000);
      	//move(10,10);



      	stopp();
      	sleep(3000);
      	//turnRight(v, v);
      }

   }
}
