#pragma config(Sensor, S1, sensorR, sensorEV3_Color)
#pragma config(Sensor, S2, sensorM, sensorEV3_Color)
#pragma config(Sensor, S4, sensorL, sensorEV3_Color)
#pragma config(Motor, motorA, motorLeft, tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor, motorD, motorRight, tmotorEV3_Large, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#define TRUE 1
#define FALSE 0

#define LOW_C 523
#define LOW_C_SHARP 554
#define LOW_D 587
#define LOW_D_SHARP 622
#define LOW_E 659
#define LOW_F 699
#define LOW_F_SHARP 740
#define LOW_G 784
#define LOW_G_SHARP 831
#define LOW_A 880
#define LOW_A_SHARP 932
#define LOW_B 988
#define HIGH_C 1047
#define HIGH_C_SHARP 1109
#define HIGH_D 1175
#define HIGH_D_SHARP 1245
#define HIGH_E 1319
#define HIGH_F 1397
#define HIGH_F_SHARP 1475
#define HIGH_G 1568
#define HIGH_G_SHARP 1661
#define HIGH_A 1760
#define HIGH_A_SHARP 1865
#define HIGH_B 1976

#define MSEC_0_05 50
#define MSEC_0_10 100
#define MSEC_0_50 500
#define MSEC_1_00 1000



int blackValue, whiteValue, threshold;

// PID value
int v = 30;
int error = 0;
int sum = 0;
int diff = 0;
int last_error = 0;

float Kp = 0.2;
float Kd = 50;
float Ki = Kp * Kp / (4 * Kd);

void move(int motorSpeedLeft, int motorSpeedRight, int period)
{
   setMotorSpeed(motorLeft, motorSpeedLeft);
   setMotorSpeed(motorRight, motorSpeedRight);
   sleep(period);
}

// Calibration
void reading()
{
    // Calibration(black)
    while (TRUE)
    {
        displayBigTextLine(1, "Read(black)..");
        if (getButtonPress(TRUE))
        {
            for (int i = 0; i < 5; i++)
            {
                blackValue += getColorReflected(sensorM);
                sleep(10);
            }

            playImmediateTone(LOW_C, MSEC_0_05);
            sleep(MSEC_0_50);
            displayBigTextLine(1, "(black)done");
            sleep(1500);
            break;
        }
    }

    // Calibration(white)
    while (TRUE)
    {
        displayBigTextLine(1, "Read(white)..");
        if (getButtonPress(TRUE))
        {
            for (int i = 0; i < 5; i++)
            {
                whiteValue += getColorReflected(sensorM);
                sleep(10);
            }

            playImmediateTone(HIGH_C, MSEC_0_05);
            sleep(MSEC_0_50);
            displayBigTextLine(1, "(white)done");
            sleep(1500);

            break;
        }
    }

    threshold = ((blackValue / 5 + whiteValue / 5)) / 2;
}

void go() // PID Control Running
{
    error = getColorReflected(sensorM) - threshold; // P control
    sum += error;                                             // PI control
    diff = error - last_error;                                // PID control
    //setMotorSpeed(motorLeft, v + (error * Kp + sum * Ki + diff * Kd));
    //sleep(0.5);
    //setMotorSpeed(motorRight, v - (error * Kp + sum * Ki + diff * Kd));
    //sleep(0.5);
    move(v+(error*Kp + sum*Ki + diff*Kd), v-(error*Kp + sum*Ki + diff*Kd), 1);
    last_error = error;

}

void turnleft()
{
		setMotorSpeed(motorLeft, -10);
  	setMotorSpeed(motorRight, 10);
  	sleep(1460);
}

void iscross()
{
	if(getColorReflected(sensorL)<threshold || getColorReflected(sensorR)<threshold)
        {
        	displayBigTextLine(1, "fvxfvsffgfs");
        	setMotorSpeed(motorLeft,0);
    			setMotorSpeed(motorRight,0);
    			sleep(1000);
        	setMotorSpeed(motorLeft,10);
    			setMotorSpeed(motorRight,10);
        	sleep(1000);
        	setMotorSpeed(motorLeft,0);
    			setMotorSpeed(motorRight,0);
    			sleep(1000);
        	if(getColorReflected(sensorL)<threshold && getColorReflected(sensorR)<threshold)
        	{
        		turnleft();
        	}

        	//break;
      	}
}

void justmove(int motorSpeedLeft, int motorSpeedRight) // just move forward
{
    setMotorSpeed(motorLeft, motorSpeedLeft);
    setMotorSpeed(motorRight, motorSpeedRight);
    //sleep(1);
}

void stopp()
{
    setMotorSpeed(motorLeft, 0);
    setMotorSpeed(motorRight, 0);
}



void turnRight()
{

}

void turn()
{
}

void search()
{
}



task main()
{
    blackValue = 0;
    whiteValue = 0;
    threshold = 0;
    reading();

    displayBigTextLine(1, "threshold : %d", threshold);
    sleep(2000);

    displayBigTextLine(1, "Press Botton");
    displayBigTextLine(4, "To Start");
    sleep(1500);
    displayBigTextLine(4, "");
    displayBigTextLine(1, "");

    // Ready and start
    while (TRUE)
    {
        if (getButtonPress(TRUE))
        {
            break;
        }
    }

    // Running
    while (TRUE)
    {
    		//displayBigTextLine(1, "threshold : %d", threshold);
    		//displayBigTextLine(4, "sensorM : %d", getColorReflected(sensorM));
    		//displayBigTextLine(8, "sensorL : %d", getColorReflected(sensorL));
    		//displayBigTextLine(12, "sensorR : %d", getColorReflected(sensorR));
    		//if you try to display too much, it would be legging
        go();
        iscross();
    }
}
